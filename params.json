{"name":"Strconv","tagline":"String type inference and conversion","body":"[![Build Status](https://travis-ci.org/bruth/strconv.png?branch=master)](https://travis-ci.org/bruth/strconv) [![Coverage Status](https://coveralls.io/repos/bruth/strconv/badge.png?branch=master)](https://coveralls.io/r/bruth/strconv?branch=master) [![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/bruth/strconv/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n\r\nLibrary for inferring and converting strings into native Python types. The original use case for this was reading CSV data with unknown types and converting it into native types for further manipulation.\r\n\r\n## Install\r\n\r\n**Supports Python 2.7, 3.2, and 3.3**\r\n\r\n```\r\npip install strconv\r\n```\r\n\r\n## Usage\r\n\r\n### Conversion\r\n\r\n**convert(s, include_type=False)**\r\n\r\nAttempts to convert string `s` into a non-string type. If `include_type` is true, the type name is returned as a second value.\r\n\r\n```python\r\n>>> import strconv\r\n>>> strconv.convert('1.2')\r\n1.2\r\n>>> strconv.convert('true')\r\nTrue\r\n>>> strconv.convert('2013-03-01', include_type=True)\r\n(date(2013, 3, 1), 'date')\r\n```\r\n\r\n**convert_series(i, include_type=False)**\r\n\r\nTakes an interable and returns a generator. Each value will be converted independently. If `include_type` is true, each value will be paired with it's type name.\r\n\r\n```python\r\n>>> list(strconv.convert_series(['1', '1.2', 't', '2013-01-01']))\r\n[1, 1.2, True, date(2013, 1, 1)]\r\n```\r\n\r\n**convert_matrix(m, include_type=False)**\r\n\r\nTakes a matrix (iterable of iterables) and returns a generator. Each value will be converted independently. If `include_type` is true, each value will be paired with it's type name.\r\n\r\n_A CSV reader can be directly passed into this function._\r\n\r\n```python\r\n>>> import csv\r\n>>> r = csv.reader(open('data.csv', 'rb'))\r\n>>> for row in strconv.convert_matrix(r):\r\n...     ...\r\n```\r\n\r\n### Inference\r\n\r\nThese functions are merely convenience wrappers for the above `convert*` functions to return only the converter type or the converted value's type.\r\n\r\n**infer(s, converted=False)**\r\n\r\nReturns the converter's type of the string value. If `converted` is true, the type of the converted value will be returned.\r\n\r\n```python\r\n>>> strconv.infer('1')\r\n'int'\r\n>>> strconv.infer('1', converted=True)\r\nint\r\n```\r\n\r\n**infer_series(i, n=None, size=10)**\r\n\r\nInfers the types of a series of values. The original use case for this was to take a column of data and infer all the teypes that exist in the data. This would confirm whether the data contains heterogeneous values.\r\n\r\nThe output of this is a `Types` instance which stores information and a sample of the values for inspection. If `n` is an integer, only N values will be evaluated. `size` is the number of values per type that will be stored as a sample set for inspection (greater `size` == more memory).\r\n\r\n```python\r\n>>> info = strconv.infer_series(['10', '5', '', '-1'])\r\n>>> info\r\n<Types: int=3, unknown=1>\r\n>>> info.most_common(1)\r\n[('int', 3)]\r\n>>> info.types['int'].freq()\r\n0.75\r\n```\r\n\r\n**infer_matrix(m, n=None, size=10)**\r\n\r\nSame as `infer_series` except it will take a matrix of values. Type information will be stored per column not per row. The output will be a list of `Types` instances of lenght M where `m` is of size NxM.\r\n\r\n```python\r\n>>> import csv\r\n>>> r = csv.reader(open('data.csv', 'rb'))\r\n>>> col_types = strconv.infer_matrix(r)\r\n```\r\n\r\n## Converters\r\n\r\nConverters are registered by some name and are evaluated in order. Converters should be ordered from the most specific + less complex to the least specific + most complex since once a value matches, further evaluation is stopped. Below are the built-in converters listed in order.\r\n\r\n- `int`\r\n- `float`\r\n- `bool` - case-insensitive conversion: `t`, `true`, `yes` to `True` and `f`, `false`, `no` to `False`\r\n- `date` - see `strconv.DATE_FORMATS` for the default date formats\r\n- `time` - see `strconv.TIME_FORMATS` for the default time formats\r\n- `datetime` - converts using each combination of the date and time formats with either `T` or a single space as the separate, e.g. '2013-03-20T13:05:32'\r\n\r\n## Customize\r\n\r\nType inference of strings is a very difficult thing to generalize. Often times there is subtle nuances to the data that require domain knowledge in order to infer the correct type. `strconv` makes it as simple as possible to customize the behavior of the inference and conversion.\r\n\r\n**Register Converter**\r\n\r\n```python\r\n>>> def convert_none(s):\r\n...     if s.upper() in ('\\N', 'NA', 'N/A', '', 'UNK'):\r\n...         return\r\n...     raise ValueError\r\n...\r\n>>> strconv.register_converter('none', convert_none, priority=0)\r\n>>> list(strconv.convert_series(['\\N', '', 'na', 'unk']))\r\n[None, None, None, None]\r\n```\r\n\r\n**Unregister Converter**\r\n\r\nAny of the default converters can be unregistered by name. This is recommended if the data is known not to have certain types.\r\n\r\n```python\r\nstrconv.unregister_convert('datetime')\r\n```\r\n\r\n**Strconv Class**\r\n\r\nThe `Strconv` class encapsulates all of the above functionality which makes it possible to create separate instance for different kinds of files or processing. All the above functions are simply references to the default instance. Instantiate a new empty instance:\r\n\r\n```python\r\nmystrconv = strconv.Strconv()\r\n```\r\n\r\nThe built-in converters are defined in the module:\r\n\r\n```python\r\nmystrconv.register_converter('int', strconv.convert_int)\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}